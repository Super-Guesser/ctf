## Oh my julia

Julia is a programming language for numerical analysis (from google)

We can find the jl_apply_generic functions in Julia compiler’s control flow.

I just analyze this function to understand the flow of main function which wrote with Julia Syntax.

And i finally found this function.

```C
JL_DLLEXPORT jl_value_t *jl_fptr_args(jl_value_t *f, jl_value_t **args, uint32_t nargs, jl_code_instance_t *m)
{
    while (1) {
        jl_fptr_args_t invoke = jl_atomic_load_relaxed(&m->specptr.fptr1);
        if (invoke)
            return invoke(f, args, nargs);
    }
}
```

Almost of the julia functions were invoked by this jl_fptr_args function.

And i can find the address of this program’s main flow.

The first flag part was generated by simple string comparison operations.

And the second flag part was generated by simple XOR logics.

Next the third flag part was generated by Multiplication and Shift operations.

Thus, i wrote the assembly codes which implemented brute force.



```assembly
section .text
    global _start

_start:
    mov r15, 0x0
loop:
    mov rbx, r15
    mov rdx, 0x6A959265B134ED87
    mov rax, rbx
    imul rdx
    mov rax, rdx
    shr rax, 0x3F
    sar rdx, 0xB
    add rdx, rax
    imul rax, rdx, 0x1337
    mov rcx, rbx
    sub rcx, rax
    mov rdx, 0x149B0651897000A5
    mov rax, rbx
    imul rdx
    xor eax, eax
    cmp rcx, 0x8FF
    je next
    add r15, 0x1
    cmp r15, 0x7f7f7f7f
    je abort
    jmp loop
next:
    mov rcx, rdx
    shr rcx, 0x3F
    sar rdx, 0x9
    add rdx, rcx
    imul rcx, rdx, 0x18D9
    mov rdx, rbx
    sub rdx, rcx
    cmp rdx, 0x105A
    je next_2
    add r15, 0x1
    cmp r15, 0x7f7f7f7f
    je abort
    jmp loop
next_2:
    mov rdx, 0xE13BDAF0069940EB
    mov rax, rbx
    imul rdx
    add rdx, rbx
    mov rax, rdx
    shr rax, 0x3F
    sar rdx, 0xD
    add rdx, rax
    imul rax, rdx, 0x245F
    sub rbx, rax
    cmp rbx, 0x1595
    je end
    add r15, 0x1
    cmp r15, 0x7f7f7f7f
    je abort
    jmp loop
abort:
    ret
end:
    mov rax, r15
    ret
```

And the fourth flag part was generated by ror and rol, shl, shr, add, xor, .. a lot of operations.

I was cumbersome to reverse engineering this. 

But we can guess the third character is ‘L’ from this logics.



```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <limits.h>
#include <assert.h>

static inline uint8_t rol_8(uint8_t n, unsigned int c)
{
    const unsigned int mask = (CHAR_BIT * sizeof(n) - 1);
    c &= mask;
    return (n << c) | (n >> ((-c) &mask));
}

static inline uint8_t ror_8(uint8_t n, unsigned int c)
{
    const unsigned int mask = (CHAR_BIT * sizeof(n) - 1);
    c &= mask;
    return (n >> c) | (n << ((-c) & mask));
}

int main()
{
    char source[5] = { 0 };
    char temp[5] = { 0 };
    char dest[5] = { 0 };

    uint8_t dl, r9b, r10b, al, cl;

    for (int i = 0x41; i < 0x80; i++)
    {
        printf("%d\n", i);
        source[0] = (char)i;
        for (int j = 0x20; j < 0x80; j++)
        {
            source[1] = (char)j;
            for (int k = 0x20; k < 0x80; k++)
            {
                source[2] = (char)k;
                for (int m = 0x20; m < 0x80; m++)
                {
                    source[3] = (char)m;
                for (int l = 0x20; l < 0x80; l++)
                {
                    source[4] = (char)l;
                    memcpy(temp, source, 5);
                    //memcpy(temp, "mnpqr", 5);
                    r9b = temp[0];
                    dl = temp[2];
                    dl = rol_8(dl, 0x3);
                    temp[2] = dl;
                    r9b = rol_8(r9b, 0x2);
                    temp[0] = r9b;
                    dl = dl ^ temp[3];
                    dl = dl ^ r9b;
                    temp[3] = dl;
                    dl = temp[4];
                    r10b = temp[1];
                    r10b = r10b ^ dl;
                    al = r9b;
                    al = al << 3;
                    al = al ^ r10b;
                    dl = rol_8(dl, 0x4);
                    temp[4] = dl;
                    dl = dl ^ r9b;
                    cl = al;
                    cl = cl << 0x2;
                    cl = cl ^ dl;
                    temp[0] = cl;
                    r10b = r10b << 0x7;
                    al = al >> 0x1;
                    al = al | r10b;
                    temp[1] = al;
                    if (temp[0] == (char)0x59 && temp[1] == (char)0xbe && temp[2] == (char)0x62 && temp[3] == (char)0xfa && temp[4] == (char)0x04)
                    {
                        printf("%c%c%c%c%c\n", source[0], source[1], source[2], source[3], source[4]);
                    }
                }
               }
            }
        }
    }
    return 0;
}
```

The final part of flag was generated by libgmp library, but this logic is too complicate.

We have to find last 0xD bytes of flag, thus we cannot find the part of flag from brute-forcing all alphanumeric characters.

But, we can assume the candidates for the characters that make up the flag string.

We can try brute forcing with two characters, ‘z’ and ‘Z’.



```python
import os
from subprocess import Popen, PIPE

for i in range(8192):
    print(i)
    form = "{0:013b}".format(i)
    form = form.replace("1", "Z")
    form = form.replace("0", "z")
    pipe = Popen("C:\\Users\\a\\Downloads\\43bd298957c1b89c4fad9c0bf55024cc\\to_player\\crack.exe", shell=True, stdout=PIPE, stdin=PIPE)
    key = b"n0w_You_kN0w_juL1@_" + form.encode() + b"\n"
    out, err = pipe.communicate(key)
    if b"noo" not in out:
        print(form)
print("end")
```

